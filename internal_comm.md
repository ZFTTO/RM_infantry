# æ¿é—´é€šä¿¡ (InterboardComm) è¯¦ç»†è®²è§£

## ğŸ“‹ ç›®å½•
1. [åŸºæœ¬æ¦‚å¿µ](#åŸºæœ¬æ¦‚å¿µ)
2. [ä¸ºä»€ä¹ˆéœ€è¦æ¿é—´é€šä¿¡](#ä¸ºä»€ä¹ˆéœ€è¦æ¿é—´é€šä¿¡)
3. [é€šä¿¡åè®®è¯¦è§£](#é€šä¿¡åè®®è¯¦è§£)
4. [æ¶ˆæ¯æ ¼å¼](#æ¶ˆæ¯æ ¼å¼)
5. [å®ç°æ–¹å¼](#å®ç°æ–¹å¼)
6. [å…·ä½“ä»£ç ç¤ºä¾‹](#å…·ä½“ä»£ç ç¤ºä¾‹)

---

## åŸºæœ¬æ¦‚å¿µ

### ä»€ä¹ˆæ˜¯æ¿é—´é€šä¿¡ï¼Ÿ

**ä¸¤å— MCU æ¿**éœ€è¦äº’ç›¸é€šè¯ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  äº‘å° MCU (Master)                   â”‚
â”‚  â—† æ¥æ”¶é¥æ§å™¨ (DR16)                 â”‚
â”‚  â—† è®¡ç®—é¥æ§è¾“å…¥ â†’ é€Ÿåº¦ç›®æ ‡            â”‚
â”‚  â—† ã€éœ€è¦å‘Šè¯‰åº•ç›˜MCUã€‘é€Ÿåº¦æ˜¯å¤šå°‘      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ CAN æ€»çº¿ æˆ– RS485
               â”‚ ã€é€šè¿‡ä»€ä¹ˆæ–¹å¼é€šä¿¡ï¼Ÿã€‘
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åº•ç›˜ MCU (Servant)                  â”‚
â”‚  â—† ã€æ¥æ”¶æ¥è‡ªäº‘å°MCUçš„ã€‘é€Ÿåº¦ä¿¡æ¯      â”‚
â”‚  â—† æ ¹æ®é€Ÿåº¦æ§åˆ¶ 8 ä¸ªé©¬è¾¾             â”‚
â”‚  â—† ã€éœ€è¦åé¦ˆã€‘é©¬è¾¾çŠ¶æ€ç»™äº‘å°MCU     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ä¸ºä»€ä¹ˆéœ€è¦æ¿é—´é€šä¿¡ï¼Ÿ

| éœ€è¦é€šä¿¡çš„ä¿¡æ¯ | æ–¹å‘ | åŸå›  |
|-------------|------|------|
| **é€Ÿåº¦å‘½ä»¤** (vx, vy, vw) | äº‘å° â†’ åº•ç›˜ | åº•ç›˜éœ€è¦çŸ¥é“è¦è·‘å¤šå¿«ã€å¾€å“ªé‡Œè·‘ |
| **é©¬è¾¾åé¦ˆ** (ç”µæµã€è½¬é€Ÿã€æ¸©åº¦) | åº•ç›˜ â†’ äº‘å° | äº‘å°éœ€è¦çŸ¥é“åº•ç›˜çŠ¶æ€ |
| **å¿ƒè·³åŒ…** (è¿æ¥æ£€æµ‹) | åŒå‘ | æ£€æµ‹å¯¹æ–¹æ˜¯å¦è¿˜æ´»ç€ |

---

## é€šä¿¡åè®®è¯¦è§£

### é€‰æ‹©é€šä¿¡æ–¹å¼

æœ‰ä¸¤ç§æ–¹å¼è®©ä¸¤å—æ¿é€šè¯ï¼š

#### æ–¹æ¡ˆ 1ï¸âƒ£: CAN æ€»çº¿ï¼ˆæ¨èï¼Œå¿«ï¼‰
```
ä¼˜ç‚¹ï¼š
  âœ… å¿«é€Ÿ (1Mbps)
  âœ… RM2026-Core å·²æœ‰é©±åŠ¨ (FDCANInterboard)
  âœ… åŒæ—¶å¯ä»¥æ§åˆ¶é©¬è¾¾
  
ç¼ºç‚¹ï¼š
  âŒ å¦‚æœ CAN çº¿æ–­äº†ï¼Œæ— æ³•é€šä¿¡
```

#### æ–¹æ¡ˆ 2ï¸âƒ£: RS485ï¼ˆå¤‡ç”¨ï¼Œæ…¢ï¼‰
```
ä¼˜ç‚¹ï¼š
  âœ… è·ç¦»è¿œ
  âœ… æŠ—å¹²æ‰°å¼º
  âœ… ä¾¿å®œ
  
ç¼ºç‚¹ï¼š
  âŒ é€Ÿåº¦æ…¢ (115.2kbps)
  âŒ éœ€è¦é¢å¤– UART
```

#### æœ€ä¼˜æ–¹æ¡ˆï¼š**åŒå†—ä½™**ï¼ˆä¼˜å…ˆç”¨ CANï¼ŒCAN åäº†ç”¨ RS485ï¼‰
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  äº‘å° MCU   â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”˜
      â”‚   â”‚
   CAN   RS485
      â”‚   â”‚
â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”
â”‚  åº•ç›˜ MCU   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å¹³æ—¶ç”¨ CANï¼ˆå¿«ï¼‰
CAN æ–­äº†è‡ªåŠ¨åˆ‡æ¢ RS485ï¼ˆä¿è¯ä¸ä¼šæ–­ï¼‰
```

---

## æ¶ˆæ¯æ ¼å¼

### æ¶ˆæ¯ç±»å‹ 1ï¸âƒ£: é€Ÿåº¦å‘½ä»¤ (VelocityCommand)

**äº‘å° MCU â†’ åº•ç›˜ MCU**

```cpp
// ç»“æ„ä½“ï¼ˆæ¯ä¸ªå˜é‡å å¤šå°‘å­—èŠ‚ï¼‰
struct VelocityCommand {
    float vx;              // 4å­—èŠ‚ - å‰è¿›é€Ÿåº¦ (m/s)
    float vy;              // 4å­—èŠ‚ - æ¨ªå‘é€Ÿåº¦ (m/s)
    float vw;              // 4å­—èŠ‚ - æ—‹è½¬é€Ÿåº¦ (rad/s)
    uint8_t enable;        // 1å­—èŠ‚ - ä½¿èƒ½æ ‡å¿— (0/1)
    uint8_t mode;          // 1å­—èŠ‚ - æ§åˆ¶æ¨¡å¼
    uint32_t timestamp;    // 4å­—èŠ‚ - æ—¶é—´æˆ³ï¼ˆç”¨äºè¶…æ—¶æ£€æµ‹ï¼‰
    uint8_t reserved[2];   // 2å­—èŠ‚ - é¢„ç•™
};
// æ€»å…±ï¼š16å­—èŠ‚
```

**å‘é€é—´éš”**: æ¯ 20ms å‘ä¸€æ¬¡ï¼ˆ50Hz é¢‘ç‡ï¼‰

**è¶…æ—¶æ£€æµ‹**: å¦‚æœ 50ms æ²¡æ”¶åˆ°æ–°å‘½ä»¤ï¼Œåº•ç›˜ç«‹å³åœæ­¢

### æ¶ˆæ¯ç±»å‹ 2ï¸âƒ£: é©¬è¾¾åé¦ˆ (MotorFeedback)

**åº•ç›˜ MCU â†’ äº‘å° MCU**ï¼ˆå¯é€‰çš„ï¼Œç”¨æ¥åé¦ˆé©¬è¾¾çŠ¶æ€ï¼‰

```cpp
struct MotorFeedback {
    uint8_t connected_motors;  // 1å­—èŠ‚ - é©¬è¾¾è¿æ¥çŠ¶æ€ (ä½æ ‡å¿—)
                              // bit 0-3: è½¬å‘é©¬è¾¾ (3508)
                              // bit 4-7: é€Ÿåº¦é©¬è¾¾ (7015)
    uint8_t status;            // 1å­—èŠ‚ - MCU çŠ¶æ€
    int16_t avg_speed;         // 2å­—èŠ‚ - å¹³å‡è½¬é€Ÿ (RPM)
    int16_t avg_current;       // 2å­—èŠ‚ - å¹³å‡ç”µæµ (AÃ—10)
    int16_t avg_temp;          // 2å­—èŠ‚ - å¹³å‡æ¸©åº¦ (Â°CÃ—10)
    uint32_t timestamp;        // 4å­—èŠ‚ - æ—¶é—´æˆ³
};
// æ€»å…±ï¼š16å­—èŠ‚
```

### æ¶ˆæ¯ç±»å‹ 3ï¸âƒ£: å¿ƒè·³åŒ… (Heartbeat)

**åŒå‘**ï¼ˆä¸¤å—æ¿éƒ½å¯ä»¥å‘ï¼‰

```cpp
struct Heartbeat {
    uint8_t source;        // å“ªå—æ¿å‘çš„ (0=äº‘å°, 1=åº•ç›˜)
    uint16_t tx_count;     // å‘äº†å¤šå°‘æ¡æ¶ˆæ¯
    uint16_t rx_count;     // æ”¶äº†å¤šå°‘æ¡æ¶ˆæ¯
    uint32_t uptime;       // MCU å¯åŠ¨å¤šä¹…äº† (ms)
};
// æ€»å…±ï¼š12å­—èŠ‚
```

---

## å®ç°æ–¹å¼

### CAN æ¶ˆæ¯ ID åˆ†é…

```
æ¶ˆæ¯ç±»å‹              CAN ID    ä¼˜å…ˆçº§    å‘¨æœŸ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
VelocityCommand      0x120     é«˜       20ms
MotorFeedback        0x121     ä¸­       100ms
Heartbeat            0x122     ä½       100ms
```

### æ¶ˆæ¯æ€ä¹ˆå‘å’Œæ”¶ï¼Ÿ

#### å‘é€ç«¯ (Cloud MCU äº‘å°æ¿)

```
[é¥æ§è¾“å…¥]
   â†“
[è®¡ç®—é€Ÿåº¦]  (vx, vy, vw)
   â†“
[æ‰“åŒ…æˆæ¶ˆæ¯]
   struct VelocityCommand cmd;
   cmd.vx = 2.0;  // å‰è¿› 2 m/s
   cmd.vy = 0.0;
   cmd.vw = 0.0;
   cmd.timestamp = now_ms;
   â†“
[åºåˆ—åŒ–ä¸ºå­—èŠ‚]
   uint8_t buffer[16];
   memcpy(buffer, &cmd, 16);
   â†“
[é€šè¿‡ CAN æˆ– RS485 å‘é€]
   CAN.send(0x120, buffer, 16);
   â†“
[å®Œæˆ]
```

#### æ¥æ”¶ç«¯ (Chassis MCU åº•ç›˜æ¿)

```
[CAN æˆ– RS485 æ¥æ”¶åˆ°æ•°æ®]
   â†“
[ååºåˆ—åŒ–ï¼ˆæŠŠå­—èŠ‚è½¬å›ç»“æ„ä½“ï¼‰]
   struct VelocityCommand cmd;
   memcpy(&cmd, buffer, 16);
   â†“
[æå–é€Ÿåº¦ä¿¡æ¯]
   float vx = cmd.vx;  // 2.0 m/s
   float vy = cmd.vy;  // 0.0
   float vw = cmd.vw;  // 0.0
   â†“
[ä¼ ç»™åº•ç›˜æ§åˆ¶å™¨]
   SwerveChassisController::setVelocityTarget(vx, vy, vw);
   â†“
[å®Œæˆ]
```

---

## å…·ä½“ä»£ç ç¤ºä¾‹

### äº‘å° MCU çš„ä»£ç 

#### 1. åˆå§‹åŒ–ï¼ˆå¯åŠ¨æ—¶è¿è¡Œä¸€æ¬¡ï¼‰

```cpp
// main.cpp
void cloudMCU_init() {
    // åˆå§‹åŒ–é¥æ§å™¨
    DR16::getInstance().init();
    
    // åˆå§‹åŒ–æ¿é—´é€šä¿¡ï¼ˆCAN + RS485ï¼‰
    InterboardCommManager::init();
    
    // åˆå§‹åŒ–é¥æ§å¤„ç†å™¨
    RemoteHandler::init();
}
```

#### 2. å®šæœŸä»»åŠ¡ï¼ˆFreeRTOS ä»»åŠ¡ï¼Œæ¯ 20ms è¿è¡Œä¸€æ¬¡ï¼‰

```cpp
// åœ¨ main.cpp ä¸­åˆ›å»ºè¿™ä¸ªä»»åŠ¡
void cloudMCU_remoteTask(void *pvParam) {
    static TickType_t lastWakeTime = xTaskGetTickCount();
    
    while (true) {
        // ã€æ­¥éª¤ 1ã€‘è¯»é¥æ§å™¨æ•°æ®
        const auto &rc_data = DR16::getInstance().getRcData();
        
        if (!rc_data.is_connected) {
            // é¥æ§æ–­äº†ï¼Œå®‰å…¨åœæ­¢
            vTaskDelay(pdMS_TO_TICKS(20));
            continue;
        }
        
        // ã€æ­¥éª¤ 2ã€‘æŠŠåŸå§‹é¥æ§å€¼è½¬æˆé€Ÿåº¦
        // ch0 (1024Â±660) â†’ vy (Â±2.0 m/s)
        // ch1 (1024Â±660) â†’ vx (Â±2.0 m/s)
        // ch2 (1024Â±660) â†’ vw (Â±3.14 rad/s)
        
        float vx = (rc_data.rc.ch1 - 1024) / 660.0f * 2.0f;  // å½’ä¸€åŒ– + ç¼©æ”¾
        float vy = (rc_data.rc.ch0 - 1024) / 660.0f * 2.0f;
        float vw = (rc_data.rc.ch2 - 1024) / 660.0f * 3.14f;
        
        // ã€æ­¥éª¤ 3ã€‘æ‰“åŒ…æˆæ¶ˆæ¯
        VelocityCommand cmd;
        cmd.vx = vx;
        cmd.vy = vy;
        cmd.vw = vw;
        cmd.enable_chassis = 1;  // ä½¿èƒ½
        cmd.timestamp = xTaskGetTickCount();  // è®°å½•å‘é€æ—¶é—´
        
        // ã€æ­¥éª¤ 4ã€‘é€šè¿‡æ¿é—´é€šä¿¡å‘é€
        InterboardCommManager::sendVelocityCommand(cmd);
        
        // å»¶è¿Ÿåˆ°ä¸‹ä¸€ä¸ª 20ms
        vTaskDelayUntil(&lastWakeTime, pdMS_TO_TICKS(20));
    }
}

// åœ¨ main() ä¸­åˆ›å»ºè¿™ä¸ªä»»åŠ¡
xTaskCreateStatic(
    cloudMCU_remoteTask,
    "RemoteHandler",
    512,  // æ ˆå¤§å°
    nullptr,
    5,  // ä¼˜å…ˆçº§
    remoteHandlerStack,  // æ ˆç¼“å†²åŒº
    &remoteHandlerTCB
);
```

### åº•ç›˜ MCU çš„ä»£ç 

#### 1. åˆå§‹åŒ–ï¼ˆå¯åŠ¨æ—¶è¿è¡Œä¸€æ¬¡ï¼‰

```cpp
void chassisMCU_init() {
    // åˆå§‹åŒ–é©¬è¾¾æ¡†æ¶
    DJIMotor::init();
    
    // åˆå§‹åŒ–æ¿é—´é€šä¿¡ï¼ˆCAN + RS485ï¼‰
    InterboardCommManager::init();
    
    // åˆå§‹åŒ–åº•ç›˜æ§åˆ¶å™¨
    SwerveChassisController::init();
    
    // ã€å…³é”®ã€‘æ³¨å†Œå›è°ƒå‡½æ•°ï¼šå½“æ”¶åˆ°é€Ÿåº¦å‘½ä»¤æ—¶åšä»€ä¹ˆ
    InterboardCommManager::registerVelocityCommandCallback(
        [](const VelocityCommand &cmd) {
            // æ”¶åˆ°äº†äº‘å° MCU å‘æ¥çš„é€Ÿåº¦å‘½ä»¤
            // ç«‹å³å‘Šè¯‰åº•ç›˜æ§åˆ¶å™¨
            SwerveChassisController::setVelocityTarget(
                cmd.vx,           // å‰è¿›é€Ÿåº¦
                cmd.vy,           // æ¨ªå‘é€Ÿåº¦
                cmd.vw,           // æ—‹è½¬é€Ÿåº¦
                cmd.enable_chassis  // æ˜¯å¦ä½¿èƒ½
            );
        }
    );
}
```

#### 2. å®šæœŸä»»åŠ¡ï¼ˆæ¯ 10ms è¿è¡Œä¸€æ¬¡ï¼Œ100Hzï¼‰

```cpp
void chassisMCU_motorTask(void *pvParam) {
    static TickType_t lastWakeTime = xTaskGetTickCount();
    
    while (true) {
        // ã€è‡ªåŠ¨ã€‘è¿è¡Œåº•ç›˜æ§åˆ¶å™¨
        // ï¼ˆé‡Œé¢ä¼šè¯»å½“å‰é€Ÿåº¦å‘½ä»¤ï¼Œè¿è¡Œ ikineï¼Œé©±åŠ¨é©¬è¾¾ï¼‰
        SwerveChassisController::update();
        
        // å»¶è¿Ÿåˆ°ä¸‹ä¸€ä¸ª 10ms
        vTaskDelayUntil(&lastWakeTime, pdMS_TO_TICKS(10));
    }
}

// åœ¨ main() ä¸­åˆ›å»ºè¿™ä¸ªä»»åŠ¡
xTaskCreateStatic(
    chassisMCU_motorTask,
    "ChassisControl",
    1024,
    nullptr,
    10,  // é«˜ä¼˜å…ˆçº§
    motorTaskStack,
    &motorTaskTCB
);
```

---

## é€šä¿¡æµç¨‹å›¾

### æ­£å¸¸æƒ…å†µï¼ˆä¸€åˆ‡å·¥ä½œï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ—¶é—´è½´ï¼ˆæ—¶é—´å•ä½ï¼šæ¯«ç§’ msï¼‰                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

t=0ms    [äº‘å° MCU è¯»é¥æ§]
         æ‘‡æ†å‘å‰
         ch1 = 1400 (1024 + 376)
         â†“
         è®¡ç®—ï¼švx = (1400-1024)/660 * 2.0 = 1.14 m/s
         â†“
         [å‘é€ VelocityCommand: vx=1.14, vy=0, vw=0]
         â†“ CAN (å»¶è¿Ÿ <1ms)
         
t=1ms    [åº•ç›˜ MCU æ”¶åˆ°]
         â†“ å›è°ƒå‡½æ•°
         SwerveChassisController::setVelocityTarget(1.14, 0, 0)
         â†“ å­˜å‚¨é€Ÿåº¦ç›®æ ‡

t=10ms   [åº•ç›˜ MCU ä»»åŠ¡è¿è¡Œ]
         â†“ è¯»é€Ÿåº¦ç›®æ ‡ (1.14, 0, 0)
         â†“ è¿è¡Œ ikine è®¡ç®—è½¬å‘è§’å’Œè½¬é€Ÿ
         â†“ è¿è¡Œ 4 ä¸ªè½¬å‘ PID ç¯
         â†“ è¿è¡Œ 4 ä¸ªé€Ÿåº¦ PID ç¯
         â†“ å‘é€é©¬è¾¾å‘½ä»¤åˆ° CAN
         
t=20ms   [äº‘å° MCU å†æ¬¡å‘é€]
         æ‘‡æ†ç»§ç»­å‘å‰
         [å‘é€æ–°çš„ VelocityCommand]

... å¾ªç¯ ...
```

### å¼‚å¸¸æƒ…å†µ 1ï¸âƒ£ï¼šé€Ÿåº¦å‘½ä»¤è¶…æ—¶ï¼ˆæ— å“åº”ï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ—¶é—´è½´                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

t=0ms    [äº‘å° MCU å‘é€]
         
t=1ms    [åº•ç›˜ MCU æ”¶åˆ°]
         velocity_timeout_counter = 0

t=20ms   [äº‘å° MCU åˆå‘é€]

t=21ms   [åº•ç›˜ MCU æ”¶åˆ°]
         velocity_timeout_counter = 0

t=50ms   ã€é¥æ§å™¨æ‰çº¿æˆ– CAN çº¿æ–­ã€‘
         [äº‘å° MCU æ— æ³•å‘é€]
         
t=51ms   [åº•ç›˜ MCU æ£€æŸ¥ï¼šè·ç¦»ä¸Šæ¬¡æ”¶åˆ°å·²è¿‡ 30ms]

t=70ms   [åº•ç›˜ MCU æ£€æŸ¥ï¼šè·ç¦»ä¸Šæ¬¡æ”¶åˆ°å·²è¿‡ 50ms]
         âœ— è¶…æ—¶ï¼ï¼
         â†“
         ã€ç«‹å³åšã€‘velocity_target = {0, 0, 0}
         ã€ç«‹å³åœæ­¢ã€‘æ‰€æœ‰é©¬è¾¾ = 0
         
t=71ms   [åº•ç›˜å®‰å…¨åœæ­¢]

... åº•ç›˜ä¿æŒåœæ­¢çŠ¶æ€ç›´åˆ°æ”¶åˆ°æ–°çš„é€Ÿåº¦å‘½ä»¤ ...
```

### å¼‚å¸¸æƒ…å†µ 2ï¸âƒ£ï¼šCAN æ–­ï¼Œè‡ªåŠ¨åˆ‡æ¢ RS485

```
åŸæœ¬ï¼š
    äº‘å° â”€â”€CANâ”€â”€â†’ åº•ç›˜  (1Mbps, å¿«)

CAN çº¿æ–­äº†ï¼š
    äº‘å° â”€â”€CANâ”€â”€â”€âœ—  åº•ç›˜
    â”‚
    â””â”€â”€RS485â”€â”€â†’ åº•ç›˜  (115.2kbps, æ…¢)

è™½ç„¶æ…¢äº†ï¼Œä½†è¿˜èƒ½é€šä¿¡ï¼
```

---

## è¶…æ—¶ä¿æŠ¤æœºåˆ¶

### ä¸ºä»€ä¹ˆéœ€è¦è¶…æ—¶æ£€æµ‹ï¼Ÿ

å‡è®¾ï¼š
- äº‘å° MCU æ¯ 20ms å‘ä¸€æ¬¡é€Ÿåº¦å‘½ä»¤
- åº•ç›˜ MCU æœŸæœ›æ¯ 20ms æ”¶ä¸€æ¬¡

**å¦‚æœé€šä¿¡ä¸­æ–­**ï¼ˆCAN çº¿æ–­äº†ã€äº‘å° MCU æ­»æœºäº†...ï¼‰ï¼š
- åº•ç›˜ MCU ä»ç„¶åœ¨ç”¨ã€æ—§çš„ã€‘é€Ÿåº¦å‘½ä»¤æ§åˆ¶é©¬è¾¾
- æœºå™¨ä¼šä¸€ç›´å†²å‘å‰ï¼Œç›´åˆ°ç¢°æ’ï¼âš ï¸

**è§£å†³æ–¹æ¡ˆï¼šè¶…æ—¶æ£€æµ‹**

```cpp
// ä¼ªä»£ç 
if (è·ç¦»ä¸Šæ¬¡æ”¶åˆ°é€Ÿåº¦å‘½ä»¤è¶…è¿‡ 50ms) {
    velocity_target = {0, 0, 0};  // ç«‹å³åœæ­¢
    velocity_enabled = false;
}
```

---

## æ€»ç»“

### æ¿é—´é€šä¿¡åšä»€ä¹ˆï¼Ÿ

| åŠŸèƒ½ | è¯´æ˜ |
|------|------|
| **å‘é€é€Ÿåº¦å‘½ä»¤** | äº‘å° MCU å‘Šè¯‰åº•ç›˜ï¼š"è¦è·‘ vx=2.0, vy=0, vw=0" |
| **æ¥æ”¶é€Ÿåº¦åé¦ˆ** | åº•ç›˜ MCU å‘Šè¯‰äº‘å°ï¼š"ç°åœ¨é©¬è¾¾æ¸©åº¦é«˜äº†" |
| **å¿ƒè·³åŒ…** | äº’ç›¸æ£€æŸ¥å¯¹æ–¹æ˜¯å¦è¿˜æ´»ç€ |
| **è¶…æ—¶ä¿æŠ¤** | å¦‚æœ 50ms æ²¡æ”¶åˆ°å‘½ä»¤ï¼Œè‡ªåŠ¨åœæ­¢ |
| **åŒå†—ä½™** | CAN åäº†è‡ªåŠ¨ç”¨ RS485 |

### ä¸‰ä¸ªå…³é”®ç‚¹

âœ… **VelocityCommand** (0x120)
- äº‘å° â†’ åº•ç›˜
- æ¯ 20ms å‘ä¸€æ¬¡
- è¶…æ—¶ 50ms åœæ­¢

âœ… **MotorFeedback** (0x121)
- åº•ç›˜ â†’ äº‘å°ï¼ˆå¯é€‰ï¼‰
- é©¬è¾¾çŠ¶æ€åé¦ˆ

âœ… **Heartbeat** (0x122)
- åŒå‘å¿ƒè·³
- è¿æ¥æ£€æµ‹

### ä»£ç æ¡†æ¶

**äº‘å° MCU**:
```cpp
RemoteHandler::update();  // æ¯ 20ms è¯»é¥æ§ã€å‘é€Ÿåº¦å‘½ä»¤
```

**åº•ç›˜ MCU**:
```cpp
// åˆå§‹åŒ–æ—¶ï¼š
InterboardCommManager::registerVelocityCommandCallback(...);
SwerveChassisController::init();

// æ¯ 10msï¼š
SwerveChassisController::update();  // æ¥æ”¶é€Ÿåº¦ã€é©±åŠ¨é©¬è¾¾
```

---

å¸Œæœ›è¿™ä¸ªè®²è§£å¸®ä½ ç†è§£äº†æ¿é—´é€šä¿¡ï¼æœ‰é—®é¢˜å¯ä»¥ç»§ç»­é—®ã€‚
